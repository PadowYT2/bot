"use strict";var __importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};const discord_js_1=require("discord.js"),flow_1=require("../constants/flows/flow"),{triggers:allTriggers,actions:allActions}=flow_1.flow,constants_1=require("../constants"),flows_1=__importDefault(require("../constants/flows/")),{limitFlows:limitFlows,limitTriggers:limitTriggers,limitActions:limitActions}=flows_1.default,utils_1=require("./utils"),database_1=__importDefault(require("../database/"));module.exports=async t=>{const e=await database_1.default.guild(t.guild.id),s=(0,constants_1.getPermissionLevel)(t.member),i=t.content;if(i.startsWith("!")&&s>=1)return;let{count:a,user:o,modules:r,flows:l,users:n}=e.get(),c=Object.keys(l).slice(0,limitFlows);if(t.client.loading)return(0,utils_1.deleteMessage)(t);if(!r.includes("allow-spam")&&t.author.id===o||!r.includes("talking")&&i!==`${a+1}`||i.split(" ")[0]!==`${a+1}`){const s={count:a,score:n[t.author.id]||0,message:t,countingMessage:t,gdb:e};(0,utils_1.deleteMessage)(t);for(const e of c)try{const i=l[e];if(i.triggers.slice(0,limitTriggers).find((t=>"countfail"===t.type)))for(const e of i.actions.slice(0,limitActions).filter((t=>t)))try{await allActions[e.type].run(s,e.data)}catch(t){}}catch(t){}return}a++,e.addToCount(t.member);let u=t;if("DM"===t.channel.type||t.channel instanceof discord_js_1.ThreadChannel)return;if(r.includes("webhook"))try{let e=(await t.channel.fetchWebhooks()).find((t=>"Counting"===t.name));e||(e=await t.channel.createWebhook("Counting")),e&&(u=await e.send({content:i,username:t.author.username,avatarURL:t.author.displayAvatarURL({dynamic:!0}),allowedMentions:{users:[],roles:[],parse:[]}}),(0,utils_1.deleteMessage)(t))}catch(t){}else if(r.includes("embed"))try{u=await t.channel.send({embeds:[{description:`${t.author}: ${i}`,color:t.member.displayColor||3553598}]}),(0,utils_1.deleteMessage)(t)}catch(t){}e.set("message",u.id);const d={count:a,score:n[t.author.id]||0,message:t,countingMessage:u,gdb:e};for(const e of c)try{const s=l[e];let i;for(const t of s.triggers.slice(0,limitTriggers).filter((t=>t)))if(i=await allTriggers[t.type].check(d,t.data),i)break;if(i)for(const e of s.actions.slice(0,limitActions).filter((t=>t)))try{await allActions[e.type].run(d,e.data)}catch(t){}}catch(t){}};