"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flowWalkthrough = exports.formatExplanation = void 0;
const flow_1 = require("./flow");
const _1 = __importDefault(require("./"));
async function formatExplanation({ type, data }) {
    let { properties, explanation } = flow_1.flow.triggers[type] || flow_1.flow.actions[type];
    for (const i in properties)
        explanation = explanation.replace(`{${i}}`, await properties[i].format(data[i]));
    return explanation;
}
exports.formatExplanation = formatExplanation;
;
const allActionTypes = Object.keys(flow_1.flow.actions);
const allActions = Object.values(flow_1.flow.actions);
const allTriggerTypes = Object.keys(flow_1.flow.triggers);
const allTriggers = Object.values(flow_1.flow.triggers);
async function flowWalkthrough(guild, author, channel, newFlow, generateEmbed, pinned) {
    while (newFlow.triggers.length < _1.default.limitTriggers)
        newFlow.triggers.push(null);
    while (newFlow.actions.length < _1.default.limitActions)
        newFlow.actions.push(null);
    let editing = true, successStatus = false;
    while (editing) {
        try {
            await pinned.edit({ content: null, embeds: [await generateEmbed()] });
            const inputs = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"] });
            const input = inputs.first(), messagesToDelete = [input];
            const args = input.content?.split(" ");
            const command = args.shift().toLowerCase();
            if (command == "edit" && ["trigger", "action"].includes(args[0]) && parseInt(args[1])) {
                const slot = parseInt(args[1]);
                if (args[0] == "trigger") {
                    if (slot > _1.default.limitTriggers)
                        messagesToDelete.push(await channel.send(`‚ùå –í—ã –º–æ–∂–µ—Ç–µ –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ ${_1.default.limitTriggers} —Ç—Ä–∏–≥–≥–µ—Ä–∞(-–æ–≤) –Ω–∞ –ø–æ—Ç–æ–∫.`));
                    else {
                        messagesToDelete.push(await channel.send({
                            embeds: [{
                                    title: `üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä –Ω–∞ —Å–ª–æ—Ç ${slot}`,
                                    description: "0 - **–û—á–∏—Å—Ç–∏—Ç—å**\n\n" +
                                        allTriggers.map((trigger, index) => `${index + 1} - **${trigger.short}**${trigger.long ? `\n${trigger.long}` : ""}`).join("\n\n"),
                                    timestamp: Date.now()
                                }]
                        }));
                        const selections = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 1800000, errors: ["time"] });
                        const selection = selections.first(), newTriggerIndex = parseInt(selection.content);
                        messagesToDelete.push(selection);
                        if (newTriggerIndex == 0) {
                            newFlow.triggers[slot - 1] = null;
                            messagesToDelete.push(await channel.send({
                                embeds: [{
                                        title: `‚úÖ –¢—Ä–∏–≥–≥–µ—Ä ${slot} –æ—á–∏—â–µ–Ω!`,
                                        timestamp: Date.now()
                                    }]
                            }));
                        }
                        else if (!newTriggerIndex || newTriggerIndex > allTriggerTypes.length)
                            messagesToDelete.push(await channel.send("‚ú¥Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ç—Ä–∏–≥–≥–µ—Ä. –û—Ç–º–µ–Ω–µ–Ω–æ."));
                        else {
                            let trigger = allTriggers[newTriggerIndex - 1], newTrigger = {
                                type: allTriggerTypes[newTriggerIndex - 1],
                                data: []
                            };
                            for (const property of trigger.properties) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                            title: `‚úèÔ∏è –£–∫–∞–∂–∏—Ç–µ ${property.short}`,
                                            description: property.help || undefined,
                                            timestamp: Date.now()
                                        }]
                                }));
                                const values = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 1800000, errors: ["time"] });
                                const value = values.first(), convertedValue = await property.convert(value.content, { guild });
                                messagesToDelete.push(value);
                                if (convertedValue == null) {
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                                title: "‚ùå –ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç—Ä–∏–≥–≥–µ—Ä–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
                                                timestamp: Date.now()
                                            }]
                                    }));
                                    break;
                                }
                                else
                                    newTrigger.data.push(convertedValue);
                            }
                            ;
                            if (newTrigger.data.length == trigger.properties.length) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                            title: `üí® –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä ${slot}`,
                                            description: [
                                                "**–≠—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ? –ù–∞–ø–∏—à–∏—Ç–µ `–¥–∞` –∏–ª–∏ `–Ω–µ—Ç`.**",
                                                `${(await formatExplanation(newTrigger)).split("\n").map((l) => `> ${l}`).join("\n")}`
                                            ].join("\n"),
                                            timestamp: Date.now()
                                        }]
                                }));
                                const confirmations = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 1800000, errors: ["time"] });
                                const confirmation = confirmations.first(), confirmed = confirmation.content.toLowerCase() == "–¥–∞";
                                messagesToDelete.push(confirmation);
                                if (confirmed) {
                                    newFlow.triggers[slot - 1] = newTrigger;
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                                title: `‚úÖ –¢—Ä–∏–≥–≥–µ—Ä ${slot} –±—ã–ª –∏–∑–º–µ–Ω—ë–Ω!`,
                                                timestamp: Date.now()
                                            }]
                                    }));
                                }
                                else
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                                title: `‚ú¥Ô∏è –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç—Ä–∏–≥–≥–µ—Ä–∞ ${slot} –±—ã–ª–æ –æ—Ç–º–µ–Ω–µ–Ω–æ.`,
                                                timestamp: Date.now()
                                            }]
                                    }));
                            }
                            ;
                        }
                        ;
                    }
                    ;
                }
                else {
                    if (slot > _1.default.limitActions)
                        messagesToDelete.push(await channel.send(`‚ùå –í—ã –º–æ–∂–µ—Ç–µ –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ ${_1.default.limitActions} –¥–µ–π—Å—Ç–≤–∏—è(-–∏–π) –Ω–∞ –ø–æ—Ç–æ–∫.`));
                    else {
                        messagesToDelete.push(await channel.send({
                            embeds: [{
                                    title: `üìù –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ —Å–ª–æ—Ç ${slot}`,
                                    description: "0 - **–û—á–∏—Å—Ç–∏—Ç—å**\n\n" +
                                        allActions.map((action, index) => `${index + 1} - **${action.short}**${action.long ? `\n${action.long}` : ""}`).join("\n\n"),
                                    timestamp: Date.now()
                                }]
                        }));
                        const selections = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 1800000, errors: ["time"] });
                        const selection = selections.first(), newActionIndex = parseInt(selection.content);
                        messagesToDelete.push(selection);
                        if (newActionIndex == 0) {
                            newFlow.actions[slot - 1] = null;
                            messagesToDelete.push(await channel.send({
                                embeds: [{
                                        title: `‚úÖ –î–µ–π—Å—Ç–≤–∏–µ ${slot} –æ—á–∏—â–µ–Ω–æ!`,
                                        timestamp: Date.now()
                                    }]
                            }));
                        }
                        else if (!newActionIndex || newActionIndex > allActionTypes.length)
                            messagesToDelete.push(await channel.send("‚ú¥Ô∏è –ù–µ–≤–µ—Ä–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ. –û—Ç–º–µ–Ω–µ–Ω–æ."));
                        else {
                            let action = allActions[newActionIndex - 1], newAction = {
                                type: allActionTypes[newActionIndex - 1],
                                data: []
                            };
                            for (const property of action.properties) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                            title: `‚úèÔ∏è –£–∫–∞–∂–∏—Ç–µ ${property.short}`,
                                            description: property.help || undefined,
                                            timestamp: Date.now()
                                        }]
                                }));
                                const values = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 1800000, errors: ["time"] });
                                const value = values.first(), convertedValue = await property.convert(value.content, { guild });
                                messagesToDelete.push(value);
                                if (convertedValue == null) {
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                                title: "‚ùå –ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ò–∑–º–µ–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.",
                                                timestamp: Date.now()
                                            }]
                                    }));
                                    break;
                                }
                                else
                                    newAction.data.push(convertedValue);
                            }
                            ;
                            if (newAction.data.length == action.properties.length) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                            title: `üí® –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ ${slot}`,
                                            description: [
                                                "**–≠—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ? –ù–∞–ø–∏—à–∏—Ç–µ `–¥–∞` –∏–ª–∏ `–Ω–µ—Ç`.**",
                                                `${(await formatExplanation(newAction)).split("\n").map((l) => `> ${l}`).join("\n")}`
                                            ].join("\n"),
                                            timestamp: Date.now()
                                        }]
                                }));
                                const confirmations = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 1800000, errors: ["time"] });
                                const confirmation = confirmations.first(), confirmed = confirmation.content.toLowerCase() == "–¥–∞";
                                messagesToDelete.push(confirmation);
                                if (confirmed) {
                                    newFlow.actions[slot - 1] = newAction;
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                                title: `‚úÖ –î–µ–π—Å—Ç–≤–∏–µ ${slot} –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–æ!`,
                                                timestamp: Date.now()
                                            }]
                                    }));
                                }
                                else
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                                title: `‚ú¥Ô∏è –ò–∑–º–µ–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è ${slot} –±—ã–ª–æ –æ—Ç–º–µ–Ω–µ–Ω–æ.`,
                                                timestamp: Date.now()
                                            }]
                                    }));
                            }
                            ;
                        }
                        ;
                    }
                    ;
                }
                ;
            }
            else if (command == "save") {
                if (newFlow.triggers.find((t) => t) && newFlow.actions.find((a) => a)) {
                    editing = false;
                    successStatus = true;
                }
                else
                    messagesToDelete.push(await channel.send("‚ùå –í—ã –¥–æ–ª–∂–Ω—ã —É–∫–∞–∑–∞—Ç—å –∫–∞–∫ –º–∏–Ω–∏–º—É–º –æ–¥–∏–Ω —Ç—Ä–∏–≥–≥–µ—Ä –∏ –æ–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ!"));
            }
            else if (command == "cancel")
                editing = false;
            else if (["help", "?"].includes(command))
                messagesToDelete.push(await channel.send(`üîó –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–º–æ—â–∏! ${pinned.url}`));
            else
                messagesToDelete.push(await channel.send("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∑–∞–ø—Ä–æ—Å. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–º–æ—â–∏!"));
            if (editing)
                setTimeout(() => channel.bulkDelete(messagesToDelete), 5000);
        }
        catch (e) {
            editing = false;
            console.log(e);
        }
        ;
    }
    ;
    return successStatus;
}
exports.flowWalkthrough = flowWalkthrough;
