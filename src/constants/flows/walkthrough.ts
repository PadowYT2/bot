import { flow } from "./flow";
import limits from "./";
import { Guild, Message, TextChannel, User } from "discord.js";

export async function formatExplanation({ type, data }) {
    let { properties, explanation } = flow.triggers[type] || flow.actions[type];
    for (const i in properties) explanation = explanation.replace(`{${i}}`, await properties[i].format(data[i]));
    return explanation;
};

const allActionTypes = Object.keys(flow.actions);
const allActions = Object.values(flow.actions);
const allTriggerTypes = Object.keys(flow.triggers);
const allTriggers = Object.values(flow.triggers);

export async function flowWalkthrough(guild: Guild, author: User, channel: TextChannel, newFlow, generateEmbed, pinned: Message) {
    while (newFlow.triggers.length < limits.limitTriggers) newFlow.triggers.push(null);
    while (newFlow.actions.length < limits.limitActions) newFlow.actions.push(null);

    let editing = true, successStatus = false;
    while (editing) {
        try {
            await pinned.edit({ content: null, embeds: [await generateEmbed()] });
            const inputs = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"] });
            const input = inputs.first(), messagesToDelete = [input];

            const args = input?.content.split(" ");
            const command = args?.shift().toLowerCase();

            if (command == "edit" && ["trigger", "action"].includes(args[0]) && parseInt(args[1])) {
                const slot = parseInt(args[1]);
                if (args[0] == "trigger") {
                    if (slot > limits.limitTriggers)
                        messagesToDelete.push(await channel.send(`‚ùå –í—ã –º–æ–∂–µ—Ç–µ –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ ${limits.limitTriggers} —Ç—Ä–∏–≥–≥–µ—Ä–∞(-–æ–≤) –Ω–∞ –ø–æ—Ç–æ–∫.`));
                    else {
                        messagesToDelete.push(await channel.send({
                            embeds: [{
                                title: `üìù –í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä –Ω–∞ —Å–ª–æ—Ç ${slot}`,
                                description:
                                    "0 - **–û—á–∏—Å—Ç–∏—Ç—å**\n\n" +
                                    allTriggers.map((trigger, index) =>
                                        `${index + 1} - **${trigger.short}**${trigger.long ? `\n${trigger.long}` : ""}`
                                    ).join("\n\n"),
                                timestamp: Date.now()
                            }]
                        }));
                        const selections = await channel.awaitMessages({ filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"] });
                        const selection = selections.first(), newTriggerIndex = parseInt(selection.content);
                        messagesToDelete.push(selection);
                        if (newTriggerIndex == 0) {
                            newFlow.triggers[slot - 1] = null;
                            messagesToDelete.push(await channel.send({
                                embeds: [{
                                    title: `‚úÖ –¢—Ä–∏–≥–≥–µ—Ä ${slot} –æ—á–∏—â–µ–Ω!`,
                                    timestamp: Date.now()
                                }]
                            }));
                        }
                        else if (!newTriggerIndex || newTriggerIndex > allTriggerTypes.length)
                            messagesToDelete.push(await channel.send("‚ú¥Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ç—Ä–∏–≥–≥–µ—Ä. –û—Ç–º–µ–Ω–µ–Ω–æ."));
                        else {
                            let trigger = allTriggers[newTriggerIndex - 1], newTrigger = {
                                type: allTriggerTypes[newTriggerIndex - 1],
                                data: []
                            };
                            for (const property of (trigger as any).properties) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                        title: `‚úèÔ∏è –£–∫–∞–∂–∏—Ç–µ ${property.short}`,
                                        description: property.help || undefined,
                                        timestamp: Date.now()
                                    }]
                                }));
                                const values = await channel.awaitMessages({
                                    filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"]
                                });
                                const value = values.first(), convertedValue = await property.convert(value.content, { guild });
                                messagesToDelete.push(value);
                                if (convertedValue == null) {
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                            title: "‚ùå –ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç—Ä–∏–≥–≥–µ—Ä–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
                                            timestamp: Date.now()
                                        }]
                                    }));
                                    break;
                                } else newTrigger.data.push(convertedValue);
                            };
                            if (newTrigger.data.length == (trigger as any).properties.length) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                        title: `üí® –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Ç—Ä–∏–≥–≥–µ—Ä ${slot}`,
                                        description: [
                                            "**–≠—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ? –ù–∞–ø–∏—à–∏—Ç–µ `–¥–∞` –∏–ª–∏ `–Ω–µ—Ç`.**",
                                            `${(await formatExplanation(newTrigger)).split("\n").map((l) => `> ${l}`).join("\n")}`
                                        ].join("\n"),
                                        timestamp: Date.now()
                                    }]
                                }));
                                const confirmations = await channel.awaitMessages({
                                    filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"]
                                });
                                const confirmation = confirmations.first(), confirmed = confirmation.content.toLowerCase() == "–¥–∞";
                                messagesToDelete.push(confirmation);
                                if (confirmed) {
                                    newFlow.triggers[slot - 1] = newTrigger;
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                            title: `‚úÖ –¢—Ä–∏–≥–≥–µ—Ä ${slot} –±—ã–ª –∏–∑–º–µ–Ω—ë–Ω!`,
                                            timestamp: Date.now()
                                        }]
                                    }));
                                } else messagesToDelete.push(await channel.send({
                                    embeds: [{
                                        title: `‚ú¥Ô∏è –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç—Ä–∏–≥–≥–µ—Ä–∞ ${slot} –±—ã–ª–æ –æ—Ç–º–µ–Ω–µ–Ω–æ.`,
                                        timestamp: Date.now()
                                    }]
                                }));
                            };
                        };
                    };
                } else {
                    if (slot > limits.limitActions)
                        messagesToDelete.push(await channel.send(`‚ùå –í—ã –º–æ–∂–µ—Ç–µ –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ ${limits.limitActions} –¥–µ–π—Å—Ç–≤–∏—è(-–∏–π) –Ω–∞ –ø–æ—Ç–æ–∫.`));
                    else {
                        messagesToDelete.push(await channel.send({
                            embeds: [{
                                title: `üìù –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ —Å–ª–æ—Ç ${slot}`,
                                description:
                                    "0 - **–û—á–∏—Å—Ç–∏—Ç—å**\n\n" +
                                    allActions.map((action, index) =>
                                        `${index + 1} - **${action.short}**${(action as any).long ? `\n${(action as any).long}` : ""}`
                                    ).join("\n\n"),
                                timestamp: Date.now()
                            }]
                        }));
                        const selections = await channel.awaitMessages({
                            filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"]
                        });
                        const selection = selections.first(), newActionIndex = parseInt(selection.content);
                        messagesToDelete.push(selection);
                        if (newActionIndex == 0) {
                            newFlow.actions[slot - 1] = null;
                            messagesToDelete.push(await channel.send({
                                embeds: [{
                                    title: `‚úÖ –î–µ–π—Å—Ç–≤–∏–µ ${slot} –æ—á–∏—â–µ–Ω–æ!`,
                                    timestamp: Date.now()
                                }]
                            }));
                        }
                        else if (!newActionIndex || newActionIndex > allActionTypes.length)
                            messagesToDelete.push(await channel.send("‚ú¥Ô∏è –ù–µ–≤–µ—Ä–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ. –û—Ç–º–µ–Ω–µ–Ω–æ."));
                        else {
                            let action = allActions[newActionIndex - 1], newAction = {
                                type: allActionTypes[newActionIndex - 1],
                                data: []
                            };
                            for (const property of (action as any).properties) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                        title: `‚úèÔ∏è –£–∫–∞–∂–∏—Ç–µ ${property.short}`,
                                        description: property.help || undefined,
                                        timestamp: Date.now()
                                    }]
                                }));
                                const values = await channel.awaitMessages({
                                    filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"]
                                });
                                const value = values.first(), convertedValue = await property.convert(value.content, { guild });
                                messagesToDelete.push(value);
                                if (convertedValue == null) {
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                            title: "‚ùå –ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ò–∑–º–µ–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –æ—Ç–º–µ–Ω–µ–Ω–æ.",
                                            timestamp: Date.now()
                                        }]
                                    }));
                                    break;
                                } else newAction.data.push(convertedValue);
                            };
                            if (newAction.data.length == (action as any).properties.length) {
                                messagesToDelete.push(await channel.send({
                                    embeds: [{
                                        title: `üí® –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ ${slot}`,
                                        description: [
                                            "**–≠—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ? –ù–∞–ø–∏—à–∏—Ç–µ `–¥–∞` –∏–ª–∏ `–Ω–µ—Ç`.**",
                                            `${(await formatExplanation(newAction)).split("\n").map((l) => `> ${l}`).join("\n")}`
                                        ].join("\n"),
                                        timestamp: Date.now()
                                    }]
                                }));
                                const confirmations = await channel.awaitMessages({
                                    filter: (m) => m.author.id == author.id, max: 1, time: 2 * 60 * 1000, errors: ["time"]
                                });
                                const confirmation = confirmations.first(), confirmed = confirmation.content.toLowerCase() == "–¥–∞";
                                messagesToDelete.push(confirmation);
                                if (confirmed) {
                                    newFlow.actions[slot - 1] = newAction;
                                    messagesToDelete.push(await channel.send({
                                        embeds: [{
                                            title: `‚úÖ –î–µ–π—Å—Ç–≤–∏–µ ${slot} –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–æ!`,
                                            timestamp: Date.now()
                                        }]
                                    }));
                                } else messagesToDelete.push(await channel.send({
                                    embeds: [{
                                        title: `‚ú¥Ô∏è –ò–∑–º–µ–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è ${slot} –±—ã–ª–æ –æ—Ç–º–µ–Ω–µ–Ω–æ.`,
                                        timestamp: Date.now()
                                    }]
                                }));
                            };
                        };
                    };
                };
            }
            else if (command == "save") {
                if (newFlow.triggers.find((t) => t) && newFlow.actions.find((a) => a)) {
                    editing = false;
                    successStatus = true;
                } else messagesToDelete.push(await channel.send("‚ùå –í—ã –¥–æ–ª–∂–Ω—ã —É–∫–∞–∑–∞—Ç—å –∫–∞–∫ –º–∏–Ω–∏–º—É–º –æ–¥–∏–Ω —Ç—Ä–∏–≥–≥–µ—Ä –∏ –æ–¥–Ω–æ –¥–µ–π—Å—Ç–≤–∏–µ!"));
            }
            else if (command == "cancel") editing = false;
            else if (["help", "?"].includes(command)) messagesToDelete.push(await channel.send(`üîó –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–º–æ—â–∏! ${pinned.url}`));
            else messagesToDelete.push(await channel.send("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∑–∞–ø—Ä–æ—Å. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –∑–∞–∫—Ä–µ–ø–ª—ë–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–º–æ—â–∏!"));

            if (editing) setTimeout(() => channel.bulkDelete(messagesToDelete), 5000);
        } catch (e) {
            editing = false;
            console.log(e);
        };
    };
    return successStatus;
};